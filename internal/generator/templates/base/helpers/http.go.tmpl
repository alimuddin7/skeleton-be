package helpers

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"{{.ProjectName}}/constants"
	"{{.ProjectName}}/models/dto"
	hModels "{{.ProjectName}}/helpers/models"

	"github.com/gofiber/fiber/v3"
	"github.com/rs/zerolog"
)

// --- Response Formatting Section ---

// ResponseFormatter formats standard API responses
func ResponseFormatter(c fiber.Ctx, err error, lang string, count int64, page *dto.Page, data interface{}) error {
	var res dto.Response
	var resKey string

	if err != nil {
		resKey = MapErrorResponse(err)
	} else {
		resKey = constants.RES_SUCCESS
		res.Data = data
		res.Count = count
		res.Page = page
	}

	res.Meta = GetNewMetaResponse(lang, resKey)

	// Add trace ID to response header
	traceID := c.Locals(constants.TRANSACTION_ID)
	if traceID != nil {
		c.Set("X-Trace-ID", fmt.Sprintf("%v", traceID))
	}

	return c.Status(MapStatusCode(res.Meta)).JSON(res)
}

// LogRequest logs the HTTP request details
func LogRequest(c fiber.Ctx, log zerolog.Logger, start time.Time) {
	log.Info().
		Str("METHOD", c.Method()).
		Str("PATH", c.Path()).
		Int("STATUS", c.Response().StatusCode()).
		Dur("DURATION", time.Since(start)).
		Msg(constants.LOG_OTHER)
}

// --- HTTP Client Section ---

// HTTPRequest performs an HTTP request using the standard library
func HTTPRequest(ctx context.Context, method, url string, headers map[string]string, body interface{}, timeout time.Duration) ([]byte, int, error) {
	var reqBody io.Reader

	if body != nil {
		jsonBody, err := json.Marshal(body)
		if err != nil {
			return nil, 0, fmt.Errorf("failed to marshal body: %w", err)
		}
		reqBody = bytes.NewBuffer(jsonBody)
	}

	req, err := http.NewRequestWithContext(ctx, method, url, reqBody)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to create request: %w", err)
	}

	for k, v := range headers {
		req.Header.Set(k, v)
	}
	
	if body != nil && req.Header.Get("Content-Type") == "" {
		req.Header.Set("Content-Type", "application/json")
	}

	client := &http.Client{
		Timeout: timeout,
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, 0, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, resp.StatusCode, fmt.Errorf("failed to read response body: %w", err)
	}

	return respBody, resp.StatusCode, nil
}

// HTTPRequestMultipart performs a multipart HTTP request
func HTTPRequestMultipart(ctx context.Context, method, url string, headers map[string]string, files map[string]string, fields map[string]string, timeout time.Duration) ([]byte, int, error) {
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	for key, path := range files {
		file, err := os.Open(path)
		if err != nil {
			return nil, 0, fmt.Errorf("failed to open file %s: %w", path, err)
		}
		defer file.Close()

		part, err := writer.CreateFormFile(key, filepath.Base(path))
		if err != nil {
			return nil, 0, fmt.Errorf("failed to create form file: %w", err)
		}
		_, err = io.Copy(part, file)
		if err != nil {
			return nil, 0, fmt.Errorf("failed to copy file content: %w", err)
		}
	}

	for key, val := range fields {
		_ = writer.WriteField(key, val)
	}

	err := writer.Close()
	if err != nil {
		return nil, 0, fmt.Errorf("failed to close writer: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, method, url, body)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Content-Type", writer.FormDataContentType())
	for k, v := range headers {
		req.Header.Set(k, v)
	}

	client := &http.Client{
		Timeout: timeout,
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, 0, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, resp.StatusCode, fmt.Errorf("failed to read response body: %w", err)
	}

	return respBody, resp.StatusCode, nil
}

// --- Meta / Error Codes Section ---

var (
	metaData map[string]map[string]dto.MetaData
	once     sync.Once
)

func loadErrorCodes() {
	once.Do(func() {
		metaData = make(map[string]map[string]dto.MetaData)
		
		// Load from errorcodes directory
		files, _ := filepath.Glob("errorcodes/errorcodes-*.json")
		if len(files) == 0 {
			files = []string{"errorcodes.json"}
		}

		for _, file := range files {
			lang := extractLanguageCode(file)
			data, err := os.ReadFile(file)
			if err != nil {
				continue
			}

			var tempData []hModels.ErrorCodeElement
			if err := json.Unmarshal(data, &tempData); err != nil {
				continue
			}
			
			langMap := make(map[string]dto.MetaData)
			for _, entry := range tempData {
				langMap[entry.Key] = entry.Content
			}
			metaData[lang] = langMap
		}
	})
}

func extractLanguageCode(filename string) string {
	base := filepath.Base(filename)
	if base == "errorcodes.json" {
		return "en"
	}
	parts := strings.Split(base, "-")
	if len(parts) < 2 {
		return "en"
	}
	lang := strings.TrimSuffix(parts[1], filepath.Ext(parts[1]))
	return lang
}

func GetMetaResponse(key string) dto.MetaData {
	return GetNewMetaResponse("en", key)
}

func GetNewMetaResponse(lang, key string) dto.MetaData {
	loadErrorCodes()

	if lang == "" {
		lang = "en"
	}

	serviceCode := constants.SERVICE_CODE
	if langData, exists := metaData[lang]; exists {
		if response, found := langData[key]; found {
			response.Code = strings.Replace(response.Code, "?", serviceCode, 1)
			response.Message = fmt.Sprintf("%s (%s)", response.Message, response.Code)
			return response
		}
	}

	if lang != "en" {
		if enData, exists := metaData["en"]; exists {
			if response, found := enData[key]; found {
				response.Code = strings.Replace(response.Code, "?", serviceCode, 1)
				response.Message = fmt.Sprintf("%s (%s)", response.Message, response.Code)
				return response
			}
		}
	}

	return dto.MetaData{
		Code:    fmt.Sprintf("500%v00", serviceCode),
		Title:   "Error",
		Message: fmt.Sprintf("General error (500%v00)", serviceCode),
	}
}

// MapStatusCode maps meta code to HTTP status code
func MapStatusCode(metaCode dto.MetaData) int {
	switch {
	case strings.HasPrefix(metaCode.Code, "200"):
		return http.StatusOK
	case strings.HasPrefix(metaCode.Code, "202"):
		return http.StatusAccepted
	case strings.HasPrefix(metaCode.Code, "400"):
		return http.StatusBadRequest
	case strings.HasPrefix(metaCode.Code, "401"):
		return http.StatusUnauthorized
	case strings.HasPrefix(metaCode.Code, "403"):
		return http.StatusForbidden
	case strings.HasPrefix(metaCode.Code, "404"):
		return http.StatusNotFound
	case strings.HasPrefix(metaCode.Code, "409"):
		return http.StatusConflict
	default:
		return http.StatusInternalServerError
	}
}

// MapErrorResponse maps error to response key string
func MapErrorResponse(err error) string {
	switch {
	case errors.Is(err, constants.ERR_CLIENT):
		return constants.RES_CLIENT_ERROR
	case errors.Is(err, constants.ERR_VALIDATION):
		return constants.RES_VALIDATION_ERROR
	case errors.Is(err, constants.ERR_UNAUTHORIZED):
		return constants.RES_UNAUTHORIZED_ERROR
	case errors.Is(err, constants.ERR_FORBIDDEN):
		return constants.RES_FORBIDDEN_ERROR
	case errors.Is(err, constants.ERR_NOT_FOUND):
		return constants.RES_NOT_FOUND_ERROR
	case errors.Is(err, constants.ERR_GENERAL):
		return constants.RES_GENERAL_ERROR
	default:
		return constants.RES_GENERAL_ERROR
	}
}

// ErrorType helps in error formatting
type ErrorType struct{}

func (ErrorType) GetData(data interface{}, err error) string {
	return fmt.Sprintf("error get data %v : %v", data, err)
}

func (ErrorType) SaveData(data interface{}, err error) string {
	return fmt.Sprintf("error save data %v : %v", data, err)
}

// Add more error helpers as needed...
