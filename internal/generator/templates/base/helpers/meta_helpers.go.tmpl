package helpers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"{{.ProjectName}}/constants"
	"{{.ProjectName}}/helpers/models"
	"strings"
	"sync"
)

var (
	metaData map[string]map[string]models.MetaData
	once     sync.Once
)

func loadErrorCodes() {
	once.Do(func() {
		metaData = make(map[string]map[string]models.MetaData)
		
		// Load from errorcodes directory
		files, _ := filepath.Glob("errorcodes/errorcodes-*.json")
		if len(files) == 0 {
			// Fallback to errorcodes.json if no language files found
			files = []string{"errorcodes.json"}
		}

		for _, file := range files {
			lang := extractLanguageCode(file)
			data, err := os.ReadFile(file)
			if err != nil {
				continue
			}

			var tempData []models.ErrorCodeElement
			if err := json.Unmarshal(data, &tempData); err != nil {
				continue
			}
			
			langMap := make(map[string]models.MetaData)
			for _, entry := range tempData {
				langMap[entry.Key] = entry.Content
			}
			metaData[lang] = langMap
		}
	})
}

func extractLanguageCode(filename string) string {
	base := filepath.Base(filename)
	if base == "errorcodes.json" {
		return "en" // Default
	}
	parts := strings.Split(base, "-")
	if len(parts) < 2 {
		return "en"
	}
	lang := strings.TrimSuffix(parts[1], filepath.Ext(parts[1]))
	return lang
}

func GetMetaResponse(key string) models.MetaData {
	return GetNewMetaResponse("en", key)
}

func GetNewMetaResponse(lang, key string) models.MetaData {
	loadErrorCodes()

	if lang == "" {
		lang = "en"
	}

	serviceCode := constants.SERVICE_CODE
	if langData, exists := metaData[lang]; exists {
		if response, found := langData[key]; found {
			response.Code = strings.Replace(response.Code, "?", serviceCode, 1)
			response.Message = fmt.Sprintf("%s (%s)", response.Message, response.Code)
			return response
		}
	}

	// Double fallback: if not found in requested lang, try 'en'
	if lang != "en" {
		if enData, exists := metaData["en"]; exists {
			if response, found := enData[key]; found {
				response.Code = strings.Replace(response.Code, "?", serviceCode, 1)
				response.Message = fmt.Sprintf("%s (%s)", response.Message, response.Code)
				return response
			}
		}
	}

	return models.MetaData{
		Code:    fmt.Sprintf("500%v00", serviceCode),
		Title:   "Error",
		Message: fmt.Sprintf("General error (500%v00)", serviceCode),
	}
}

func MapStatusCode(metaCode models.MetaData) int {
	switch {
	case strings.HasPrefix(metaCode.Code, "200"):
		return http.StatusOK
	case strings.HasPrefix(metaCode.Code, "202"):
		return http.StatusAccepted
	case strings.HasPrefix(metaCode.Code, "400"):
		return http.StatusBadRequest
	case strings.HasPrefix(metaCode.Code, "401"):
		return http.StatusUnauthorized
	case strings.HasPrefix(metaCode.Code, "403"):
		return http.StatusForbidden
	case strings.HasPrefix(metaCode.Code, "404"):
		return http.StatusNotFound
	case strings.HasPrefix(metaCode.Code, "409"):
		return http.StatusConflict
	default:
		return http.StatusInternalServerError
	}
}
