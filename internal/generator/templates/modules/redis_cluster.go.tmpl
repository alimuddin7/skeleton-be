package rediscluster

import (
	"context"
	"{{.ProjectName}}/configs"
	"{{.ProjectName}}/models"
	"time"

	redis "github.com/redis/go-redis/v9"
	"github.com/rs/zerolog"
)

type RedisClusterRepository interface {
	GetQueue(ctx context.Context, d time.Duration, key string) ([]string, error)
	PushJobRedis(ctx context.Context, key string, value interface{}) error
	SaveRedisExp(ctx context.Context, exp time.Duration, key string, val interface{}) error
	GetRedisKey(ctx context.Context, Key string) (string, error)
	Increment(ctx context.Context, key string) error
	HealthCheck(ctx context.Context) models.DataHealthCheck
}

type redisClusterRepository struct {
	Client *redis.ClusterClient
	Logs   zerolog.Logger
}

func InitializeRedisClusterRepository(conn *redis.ClusterClient, log zerolog.Logger) RedisClusterRepository {
	return &redisClusterRepository{
		Client: conn,
		Logs:   log,
	}
}

func ConnectRedisCluster(log zerolog.Logger) *redis.ClusterClient {
	c := context.Background()
	client := redis.NewClusterClient(&redis.ClusterOptions{
		ClusterSlots: func(ctx context.Context) ([]redis.ClusterSlot, error) {
			conf := configs.Cfg.Database.RedisCluster
			if len(conf.Address) != len(conf.SlaveAddress) {
				log.Fatal().Msg("Redis Cluster Address and SlaveAddress length mismatch")
			}
			slots := make([]redis.ClusterSlot, len(conf.Address))
			start := 0
			diff := 5461
			for i, add := range conf.Address {
				slots[i] = redis.ClusterSlot{
					Start: start,
					End:   diff,
					Nodes: []redis.ClusterNode{
						{Addr: add},
						{Addr: conf.SlaveAddress[i]},
					},
				}
				start = diff + 1
			}
			return slots, nil
		},
		RouteRandomly: true,
	})

	err := client.ForEachShard(c, func(c context.Context, shard *redis.Client) error {
		return shard.Ping(c).Err()
	})

	if err != nil {
		log.Error().Err(err).Msg("Error open redis cluster connection")
		panic("Error open redis cluster connection")
	}

	log.Info().Msg("Redis cluster connected successfully")
	return client
}

func (r *redisClusterRepository) GetQueue(ctx context.Context, d time.Duration, key string) ([]string, error) {
	return r.Client.BRPop(ctx, d, key).Result()
}

func (r *redisClusterRepository) PushJobRedis(ctx context.Context, key string, value interface{}) error {
	return r.Client.RPush(ctx, key, value).Err()
}

func (r *redisClusterRepository) SaveRedisExp(ctx context.Context, exp time.Duration, key string, val interface{}) error {
	return r.Client.Set(ctx, key, val, exp).Err()
}

func (r *redisClusterRepository) GetRedisKey(ctx context.Context, key string) (string, error) {
	return r.Client.Get(ctx, key).Result()
}

func (r *redisClusterRepository) Increment(ctx context.Context, key string) error {
	return r.Client.Incr(ctx, key).Err()
}

func (r *redisClusterRepository) HealthCheck(ctx context.Context) models.DataHealthCheck {
	res := models.DataHealthCheck{
		ServiceName: "Redis Cluster",
		StatusCode:  200,
	}
	
	err := r.Client.ForEachShard(ctx, func(ctx context.Context, shard *redis.Client) error {
		return shard.Ping(ctx).Err()
	})
	
	if err != nil {
		r.Logs.Error().Ctx(ctx).Err(err).Msg("Redis Cluster health check failed")
		res.StatusCode = 500
		res.AdditionalData = err.Error()
		return res
	}
	
	return res
}
